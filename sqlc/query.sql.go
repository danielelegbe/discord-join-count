// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteUsers = `-- name: DeleteUsers :exec
delete from users
`

func (q *Queries) DeleteUsers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteUsers)
	return err
}

const getAllTimeStats = `-- name: GetAllTimeStats :many
;

select
    u.name,
    count(distinct uj.id) as total_joins,
    sum(
        cast(
            (
                julianday(coalesce(uj.left_at, current_timestamp))
                - julianday(uj.joined_at)
            )
            * 1440 as integer
        )
    ) as total_minutes
from users u
join user_joins uj on u.id = uj.user_id
group by u.id, u.name
order by total_minutes desc
`

type GetAllTimeStatsRow struct {
	Name         string
	TotalJoins   int64
	TotalMinutes sql.NullFloat64
}

func (q *Queries) GetAllTimeStats(ctx context.Context) ([]GetAllTimeStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTimeStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTimeStatsRow
	for rows.Next() {
		var i GetAllTimeStatsRow
		if err := rows.Scan(&i.Name, &i.TotalJoins, &i.TotalMinutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodayTimeSpent = `-- name: GetTodayTimeSpent :many
;

select
    u.name,
    count(distinct uj.id) as joins_today,
    sum(
        cast(
            (
                julianday(coalesce(uj.left_at, current_timestamp))
                - julianday(uj.joined_at)
            )
            * 1440 as integer
        )
    ) as minutes_today
from users u
join user_joins uj on u.id = uj.user_id
where uj.joined_at >= date('now', 'start of day') and uj.joined_at <= current_timestamp
group by u.id
order by minutes_today desc
`

type GetTodayTimeSpentRow struct {
	Name         string
	JoinsToday   int64
	MinutesToday sql.NullFloat64
}

func (q *Queries) GetTodayTimeSpent(ctx context.Context) ([]GetTodayTimeSpentRow, error) {
	rows, err := q.db.QueryContext(ctx, getTodayTimeSpent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTodayTimeSpentRow
	for rows.Next() {
		var i GetTodayTimeSpentRow
		if err := rows.Scan(&i.Name, &i.JoinsToday, &i.MinutesToday); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTodayTimeSpent = `-- name: GetUserTodayTimeSpent :one
;

select
    u.name,
    count(distinct uj.id) as joins_today,
    sum(
        cast(
            (
                julianday(coalesce(uj.left_at, current_timestamp))
                - julianday(uj.joined_at)
            )
            * 1440 as integer
        )
    ) as minutes_today
from users u
join user_joins uj on u.id = uj.user_id
where
    u.id = ?
    and uj.joined_at >= date('now', 'start of day')
    and uj.joined_at <= current_timestamp
group by u.id
`

type GetUserTodayTimeSpentRow struct {
	Name         string
	JoinsToday   int64
	MinutesToday sql.NullFloat64
}

func (q *Queries) GetUserTodayTimeSpent(ctx context.Context, id string) (GetUserTodayTimeSpentRow, error) {
	row := q.db.QueryRowContext(ctx, getUserTodayTimeSpent, id)
	var i GetUserTodayTimeSpentRow
	err := row.Scan(&i.Name, &i.JoinsToday, &i.MinutesToday)
	return i, err
}

const getUserVoiceStats = `-- name: GetUserVoiceStats :one
select
    u.name,
    count(distinct uj.id) as total_joins,
    sum(
        cast(
            (
                julianday(coalesce(uj.left_at, current_timestamp))
                - julianday(uj.joined_at)
            )
            * 1440 as integer
        )
    ) as total_minutes,
    max(uj.joined_at) as last_join
from users u
join user_joins uj on u.id = uj.user_id
where u.id = ?
group by u.id
`

type GetUserVoiceStatsRow struct {
	Name         string
	TotalJoins   int64
	TotalMinutes sql.NullFloat64
	LastJoin     interface{}
}

func (q *Queries) GetUserVoiceStats(ctx context.Context, id string) (GetUserVoiceStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserVoiceStats, id)
	var i GetUserVoiceStatsRow
	err := row.Scan(
		&i.Name,
		&i.TotalJoins,
		&i.TotalMinutes,
		&i.LastJoin,
	)
	return i, err
}

const getWeeklyLeaderboard = `-- name: GetWeeklyLeaderboard :many
;

with
    week_start as (
        -- Get the start of current week (Monday 00:00:00)
        select
            datetime(
                'now',
                'start of day',
                '-' || case
                    strftime('%w', 'now')
                    when '0'
                    then '6'  -- If Sunday, go back 6 days
                    else cast(strftime('%w', 'now') - 1 as text)  -- Otherwise, back to Monday
                end
                || ' days'
            ) as start_date
    )
select
    u.name,
    count(distinct uj.id) as joins_this_week,
    sum(
        cast(
            (
                julianday(coalesce(uj.left_at, current_timestamp))
                - julianday(uj.joined_at)
            )
            * 1440 as integer
        )
    ) as minutes_this_week
from users u
join user_joins uj on u.id = uj.user_id
cross join week_start
where uj.joined_at >= week_start.start_date and uj.joined_at <= current_timestamp
group by u.id
order by minutes_this_week desc
limit 10
`

type GetWeeklyLeaderboardRow struct {
	Name            string
	JoinsThisWeek   int64
	MinutesThisWeek sql.NullFloat64
}

func (q *Queries) GetWeeklyLeaderboard(ctx context.Context) ([]GetWeeklyLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyLeaderboardRow
	for rows.Next() {
		var i GetWeeklyLeaderboardRow
		if err := rows.Scan(&i.Name, &i.JoinsThisWeek, &i.MinutesThisWeek); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserJoin = `-- name: InsertUserJoin :exec
;


INSERT INTO user_joins (
    user_id,
    guild_id,
    channel_id,
    joined_at
) VALUES (?, ?, ?, CURRENT_TIMESTAMP)
`

type InsertUserJoinParams struct {
	UserID    string
	GuildID   string
	ChannelID string
}

func (q *Queries) InsertUserJoin(ctx context.Context, arg InsertUserJoinParams) error {
	_, err := q.db.ExecContext(ctx, insertUserJoin, arg.UserID, arg.GuildID, arg.ChannelID)
	return err
}

const listUsers = `-- name: ListUsers :many
select id, name, created_at
from users
order by time_spent_in_minutes desc
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActiveSessions = `-- name: UpdateActiveSessions :exec
;

UPDATE user_joins
SET left_at = CURRENT_TIMESTAMP,  -- End the current session
    joined_at = CURRENT_TIMESTAMP  -- Start a new session for the same duration
WHERE user_id = ? 
AND left_at IS NULL
`

func (q *Queries) UpdateActiveSessions(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, updateActiveSessions, userID)
	return err
}

const updateUserLeave = `-- name: UpdateUserLeave :exec
UPDATE user_joins 
SET left_at = CURRENT_TIMESTAMP
WHERE user_id = ? 
AND left_at IS NULL
`

func (q *Queries) UpdateUserLeave(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, updateUserLeave, userID)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
;

INSERT INTO users (id, name)
VALUES (?, ?)
ON CONFLICT (id) DO UPDATE SET
    name = excluded.name
`

type UpsertUserParams struct {
	ID   string
	Name string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertUser, arg.ID, arg.Name)
	return err
}
